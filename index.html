<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="primesieve is a free software program and C/C++ library that generates primes using a highly optimized sieve of Eratosthenes implementation.">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <link rel="stylesheet" type="text/css" href="stylesheets/navigation_menu.css">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>primesieve - Fast C/C++ prime number generator</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>primesieve</h1>
        <h2>Fast C/C++ prime number generator</h2>
        <a href="https://github.com/kimwalisch/primesieve" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">

<div id="container">
  <nav id="navigation">
    <ul>
      <li><a href=".">Home</a></li>
      <li><a href="downloads">Downloads</a></li>
      <li><a href="build.html">Build From Source</a></li>
      <li><a href="segmented_sieve.html">Segmented Sieve</a></li>
      <li><a href="api">API Documentation</a></li>
      <li><a href="links.html">Links</a></li>
    </ul>
  </nav>
</div>

<h2>
<a name="about" class="anchor" href="#about"><span class="octicon octicon-link"></span></a>About</h2>
<p>primesieve is a free (BSD-licensed) software program and C/C++ library
for fast prime number generation. It generates the primes below 10^9 in
just 0.2 seconds on a single core of an Intel Core i7-4770 CPU from
2013. primesieve can generate primes and
<a href="http://en.wikipedia.org/wiki/Prime_k-tuple">prime k-tuplets</a>
(twin primes, prime triplets, ...) up to 2^64.</p>

<h2>
<a name="screenshot" class="anchor" href="#screenshot"><span class="octicon octicon-link"></span></a>Screenshot</h2>
<img src="screenshots/primesieve_osx_terminal.png" alt="primesieve console application" style="padding-top: 5px;  padding-bottom: 10px;"/>
<p>The above screenshot shows the first 16 prime septuplets
(7-tuplets) generated using the primesieve console application. The
<a href="screenshots.html">screenshot page</a> contains more
pictures.</p>

<h2>
<a name="algorithms" class="anchor" href="#algorithms"><span class="octicon octicon-link"></span></a>Algorithms</h2>
<p>primesieve generates primes using the segmented
<a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes">sieve of
Eratosthenes</a> with
<a href="http://en.wikipedia.org/wiki/Wheel_factorization">wheel
factorization</a>, this algorithm has a complexity of
<img src="images/Onloglogn.png" alt="O(n log log n)" class="formula"/>
operations and uses
<img src="images/Osqrtn.png" alt="O(sqrt(n))" class="formula"/>
space.</p>

<p>Segmentation is currently the best known practical improvement to
the sieve of Eratosthenes. Instead of sieving the interval
2<sup><i>n</i></sup> at once one subdivides the sieve interval into a
number of equal sized segments that are then sieved consecutively.
Segmentation drops the memory requirement of the sieve of Eratosthenes
from <img src="images/On.png" alt="O(n)" class="formula"/>
to <img src="images/Osqrtn.png" alt="O(sqrt(n))" class="formula"/>.
The segment size is usually chosen to fit into the CPU's fast L1 or L2
cache memory which significantly speeds up sieving. A segmented
version of the sieve of Eratosthenes was first published by Singleton
in 1969 [1]. Here is a <a href="segmented_sieve.html">simple implementation
of the segmented sieve of Eratosthenes</a>.</p>

<p>Wheel factorization is used to skip multiples of small primes. If a
<i>k</i>th wheel is added to the sieve of Eratosthenes then only those
multiples are crossed off that are coprime to the first <i>k</i>
primes, i.e. multiples that are divisible by any of the first <i>k</i>
primes are skipped. The 1st wheel considers only odd numbers, the 2nd
wheel (modulo 6) skips multiples of 2 and 3, the 3rd wheel (modulo 30)
skips multiples of 2, 3, 5 and so on. Pritchard has shown in [2] that
the running time of the sieve of Eratosthenes can be reduced by a
factor of <img src="images/loglogn.png" alt="log log n" class="formula"/>
if the wheel size is <img src="images/propsqrtn.png" alt="sqrt(n)" class="formula"/>
but for cache reasons the sieve of Eratosthenes usually performs best
with a modulo 30 or 210 wheel. Sorenson explains wheels in [3].</p>

<p>Additionally primesieve uses Tomás Oliveira e Silva's
<a href="http://www.ieeta.pt/~tos/software/prime_sieve.html">cache-friendly bucket list algorithm</a>
if needed [4]. This algorithm is relatively new it has
been devised by Tomás Oliveira e Silva in 2001 in order to speed up
the segmented sieve of Eratosthenes for prime numbers past 32 bits.
The idea is to store the sieving primes into lists of buckets with
each list being associated with a segment. A list of sieving primes
related to a specific segment contains only those primes that have
multiple occurrence(s) in that segment. Whilst sieving a segment only
the primes of the related list are used for sieving and each prime is
reassigned to the list responsible for its next multiple when
processed. The benefit of this approach is that it is now possible to
use segments (i.e. sieve arrays) smaller than
<img src="images/sqrtn.png" alt="sqrt(n)" class="formula"/>
without deteriorating efficiency, this is important as only small
segments that fit into the CPU's L1 or L2 cache provide fast memory
access.</p>

<h2>
<a name="implementation" class="anchor" href="#implementation"><span class="octicon octicon-link"></span></a>Implementation</h2>
<p>primesieve is written entirely in C++ and does not depend on
external libraries [5]. Its speed is mainly due to the segmentation of
the sieve of Eratosthenes which prevents cache misses when crossing
off multiples in the sieve array and the use of a bit array instead of
the more widely used boolean array. Below is a list of the
optimizations used in primesieve:</p>
<ul>
  <li>Uses a bit array with 8 flags each 30 numbers for sieving</li>
  <li>Pre-sieves multiples of small primes ≤ 19</li>
  <li>The sieving primes are being compressed to improve cache efficiency [6]</li>
  <li>Starts crossing off multiples at the square</li>
  <li>Uses a modolo 210 wheel that skips multiples of 2, 3, 5 and 7</li>
  <li>Uses specialized algorithms for small, medium and big sieving primes</li>
  <li>Two sieving primes are processed per loop iteration to increase instruction-level parallelism</li>
  <li>Parallelized (multi-threaded) using <a href="http://openmp.org/">OpenMP</a></li>
</ul>
<p>The <a href="build.html">Build From Source</a> page contains more
technical implementation details.</p>

<h2>
<a name="cpp-library" class="anchor" href="#cpp-library"><span class="octicon octicon-link"></span></a>C++ library</h2>
<p>Below is an example that shows how to generate primes in C++ using
libprimesieve. You can <a href="api">browse primesieve's API online</a>.
The <a href="build.html">Build From Source</a> page explains how
to build libprimesieve and how to link against it.</p>

<div class="highlight highlight-C++"><pre><span class="cp">#include &lt;primesieve.hpp&gt;</span>
<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// store the primes below 1000</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">primes</span><span class="p">;</span>
  <span class="n">primesieve</span><span class="o">::</span><span class="n">generate_primes</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primes</span><span class="p">);</span>

  <span class="n">primesieve</span><span class="o">::</span><span class="n">iterator</span> <span class="n">pi</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">prime</span><span class="p">;</span>

  <span class="c1">// iterate over the primes below 10^9</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">prime</span> <span class="o">=</span> <span class="n">pi</span><span class="p">.</span><span class="n">next_prime</span><span class="p">())</span> <span class="o">&lt;</span> <span class="mi">1000000000</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">prime</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h2>
<a name="c-bindings" class="anchor" href="#c-bindings"><span class="octicon octicon-link"></span></a>C bindings</h2>
<p>primesieve provides C bindings for all its functions, please refer
to <a href="api">http://primesieve.org/api</a> 
for more information.</p>

<h2>
<a name="performance" class="anchor" href="#performance"><span class="octicon octicon-link"></span></a>Performance</h2>
<p>primesieve generates the first 50,847,534 primes up to 10^9 in just
0.2 seconds on a single core of an Intel Core i7-4770 3.4GHz (year
2013), this is about 50 times faster than an ordinary C/C++ sieve of
Eratosthenes implementation and about 10,000 times faster than
trial-division. primesieve outperforms the author's older
<a href="http://primzahlen.de/referenten/Kim_Walisch/index2.htm">ecprime</a>
(fastest from 2002 to 2010) by about 30 percent and also substantially
outperforms <a href="http://cr.yp.to/primegen.html">primegen</a> the
fastest sieve of Atkin implementation on the web. Here is a
list of <a href="links.html">other fast sieve of Eratosthenes
implementations</a>.</p>

<h2 style="padding-bottom: 8px">
<a name="timings" class="anchor" href="#timings"><span class="octicon octicon-link"></span></a>Timings</h2>
<table style="width: 750px;">
<tr>
    <td class="timing_title">x</td>
    <td class="timing_title">
      <span style="white-space: nowrap;">Prime Count</span>
    </td>
    <td class="timing_title">
      <span style="white-space: nowrap;">Intel Core i5-670</span><br/>
      <span class="cpu_details">(2 x 3.47GHz, 32K L1 Data Cache)</span>
    </td>
    <td class="timing_title">
      <span style="white-space: nowrap;">AMD Phenom II X4 945</span><br/>
      <span class="cpu_details">(4 x 3.0GHz, 64K L1 Data Cache)</span>
    </td>
    <td class="timing_title">
      <span style="white-space: nowrap;">Intel Core i7-4770</span><br/>
      <span class="cpu_details">(4 x 3.4GHz, 32K L1 Data Cache)</span>
    </td>
  </tr>
<tr>
    <td class="timing">10<sup>7</sup></td>
    <td class="timing">664,579</td>
    <td class="timing">0.00s</td>
    <td class="timing">0.00s</td>
    <td class="timing">0.00s</td>
  </tr>
<tr>
    <td class="timing">10<sup>8</sup></td>
    <td class="timing">5,761,455</td>
    <td class="timing">0.01s</td>
    <td class="timing">0.01s</td>
    <td class="timing">0.01s</td>
  </tr>
<tr>
    <td class="timing">10<sup>9</sup></td>
    <td class="timing">50,847,534</td>
    <td class="timing">0.11s</td>
    <td class="timing">0.06s</td>
    <td class="timing">0.05s</td>
  </tr>
<tr>
    <td class="timing">2<sup>32</sup></td>
    <td class="timing">203,280,221</td>
    <td class="timing">0.54s</td>
    <td class="timing">0.26s</td>
    <td class="timing">0.23</td>
  </tr>
<tr>
<td class="timing">10<sup>10</sup></td>
    <td class="timing">455,052,511</td>
    <td class="timing">1.29s</td>
    <td class="timing">0.66s</td>
    <td class="timing">0.57</td>
  </tr>
<tr>
    <td class="timing">10<sup>11</sup></td>
    <td class="timing">4,118,054,813</td>
    <td class="timing">16.11s</td>
    <td class="timing">8.57s</td>
    <td class="timing">6.63s</td>
  </tr>
<tr>
    <td class="timing">10<sup>12</sup></td>
    <td class="timing">37,607,912,018</td>
    <td class="timing">208.63s</td>
    <td class="timing">122.02s</td>
    <td class="timing">77.79s</td>
  </tr>
<tr>
    <td class="timing">10<sup>13</sup></td>
    <td class="timing">346,065,536,839</td>
    <td class="timing">2629.84s</td>
    <td class="timing">1664.68s</td>
    <td class="timing">926.83</td>
  </tr>
</table>
<p><br/>The above benchmarks were run on a 64-bit Linux operating
system and primesieve was compiled using
<span style="white-space: nowrap;">GCC 4.8.</span> For each benchmark
primesieve used all available CPU cores and the sieve size was set to
the CPU's L1 data cache size per core (Intel: 32 kilobytes, AMD: 64
kilobytes).</p>

<h2 style="padding-bottom: 10px">
<a name="cpu-scaling" class="anchor" href="#cpu-scaling"><span class="octicon octicon-link"></span></a>CPU scaling</h2>
<img src="images/primesieve_cpu_scaling.png" alt="primesieve CPU scaling"/>
<p style="padding-top: 10px">The above CPU scaling benchmark was run
on a system with 8 physical CPU cores and 23 GB of memory. At each
start offset the primes inside an interval of size 10^11 were counted
using different numbers of threads. As one can see primesieve scales
well if the interval is sufficiently large.</p>

<h2>
<a name="references" class="anchor" href="#references"><span class="octicon octicon-link"></span></a>References and notes</h2>
<ol>
  <li>R. C. Singleton, "An efficient prime number generator", Communications of the ACM 12, 563-564, 1969.</li>
  <li>Paul Pritchard, "Fast compact prime number sieves (among others)", Journal of Algorithms 4 (1983), 332-344.</li>
  <li>Jonathan Sorenson, <a href="ftp://ftp.cs.wisc.edu/pub/techreports/1991/TR1028.pdf">"An analysis of two prime number sieves"</a>, Computer Science Technical Report Vol. 1028, 1991.</li>
  <li>Tomás Oliveira e Silva, <a href="http://www.ieeta.pt/~tos/software/prime_sieve.html">"Fast implementation of the segmented sieve of Eratosthenes"</a>, 2002.</li>
  <li>The primesieve GUI application (screenshot) depends on the <a href="http://qt-project.org/">Qt framework</a>.</li>
  <li>Actually it is not the sieving primes that are being compressed but their sieve and wheel indexes.</li>
</ol>

        </section>

        <aside id="sidebar">
          <a href="https://github.com/kimwalisch/primesieve/zipball/master" class="download_zip button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/kimwalisch/primesieve/tarball/master" class="download_targz button">
            <small>Download</small>
            .tar.gz file
          </a>

          <iframe src="http://ghbtns.com/github-btn.html?user=kimwalisch&repo=primesieve&type=watch&count=true&size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe>
          <p class="repo-owner" style="padding-top: 14px;"><a href="https://github.com/kimwalisch/primesieve"></a> is maintained by <a href="https://github.com/kimwalisch">kimwalisch</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

    <script src="javascripts/jquery-1.7.1.min.js" type="text/javascript"></script> 
    <script src="javascripts/modernizr-2.0.6.min.js" type="text/javascript"></script>
    <script src="javascripts/download.js" type="text/javascript"></script>
  </body>
</html>
