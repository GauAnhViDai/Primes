January 11, 2013
Kim Walisch, <kim.walisch@gmail.com>
http://primesieve.googlecode.com

Q  I want to generate primes > 2^64, is it possible to extend
   primesieve to 128 bits?

A  Technically it is possible but it makes no sense due to the
   enormous memory requirement. primesieve uses the segmented sieve of
   Eratosthenes which uses O(pi(n^0.5)) memory, e.g. near 10^25
   primesieve would need ~ 1300 GB (gigabytes) per thread!
   J. Sorenson's paper "The Pseudosquares Prime Sieve" presents an
   algorithm that can be used to generate primes up to 33 digits
   using very little memory.

Q  How can I cancel prime number generation?

A  You can cancel prime number generation immediately by throwing
   an exception from within the callback method. This has been
   thoroughly tested with many different compilers, it is even fast.
   Have a look at ../examples/cancel_prime_generation.cpp for an
   example. Currently this does not work with ParallelPrimeSieve as
   OpenMP does not support exceptions yet.

Q  Why does PrimeSieve not offer a getNextPrime() method?

A  PrimeSieve uses callbacks instead of getNextPrime() because:
   1. Callbacks are faster than getNextPrime()
   2. Callbacks are easier to implement than getNextPrime()
   3. Callbacks can be parallelized, getNextPrime() cannot

Q  How can I generate (callback) twin primes?

A  You have to modify the source code, open a terminal and cd into the
   src/soe directory, then run the following commands:

   sed -i 's/GENERATE_PRIMES/GENERATE_TWINS/g' PrimeNumberFinder.cpp
   sed -i 's/sp.index == 0/sp.index == 1/g' PrimeSieve.cpp

   Now, after recompilation the PrimeSieve::generatePrimes(*) methods
   will generate twin primes instead of primes. For each twin prime
   pair (p1, p2) the first prime p1 is called back.

Q  What are the hot spots in primesieve?

A  The two main hot spots are the sieving algorithms in
   src/soe/EratSmall.cpp and src/soe/EratBig.cpp.

Q  What are small, medium and big sieving primes?

A  In primesieve sieving primes fall into 3 categories: small, medium
   and big sieving primes, these categories correlate with the size of
   the sieve array. In primesieve small sieving primes are <= (sieve
   size in bytes) * 0.5 (1), medium sieving primes are > (1) and
   <= (sieve size in bytes) * 6 (2), and big sieving primes are > (2).

Q  How does the bit array work in primesieve?

A  primesieve uses a bit array for sieving, each byte holds the eight
   offsets { 7, 11, 13, 17, 19, 23, 29, 31 }. To remove a multiple
   e.g. 11*11 = 121 from the sieve array one must unset the
   corresponding bit using:

   sieve[121 / 30] &= bitmasks[121 % 30];

   In order to avoid the slow division and modulo instructions all
   multiples and sieving primes within primesieve are '/ 30' by
   default which allows to unset a bit using:

   sieve[multipleIndex] &= bitmasks[wheelIndex];

   Unfortunately using values divided by 30 also has a drawback, the
   calculation of the next multiple requires 1 additional add
   instruction in EratSmall and 2 additional instructions (table
   lookup & add) in EratMedium and EratBig but this is still faster.
