March 09, 2013
Kim Walisch, <kim.walisch@gmail.com>
http://primesieve.googlecode.com

Contents
========

   1. About
   2. Generate primes
   3. Generate primes OOP
   4. Count primes
   5. Print primes
   6. ParallelPrimeSieve
   7. Timing
   8. Performance tuning
   9. C++ Exceptions
  10. Cancel prime number generation
  11. Flags

1. About
========

  This file contains C++ source code examples that show how to use
  PrimeSieve and ParallelPrimeSieve objects. Both PrimeSieve and
  ParallelPrimeSieve objects can generate, print (to cout) and count
  primes and prime k-tuplets (twins, triplets, ...).

  For these examples to compile you need to build primesieve as a
  library and add it to the linker, this is explained in the
  LIBPRIMESIEVE file. The complete PrimeSieve and ParallelPrimeSieve
  API is presented in the doc/API file.

  Try it yourself!
  ----------------
  The example programs presented in this file are also stored in the
  ../examples directory and can easily be compiled using the
  Makefiles. Please read ../examples/README for more information.

2. Generate primes
==================

  API for prime generation
  ------------------------
  void PrimeSieve::generatePrimes(uint32_t start, uint32_t stop, void (*callback)(uint32_t));
  void PrimeSieve::generatePrimes(uint64_t start, uint64_t stop, void (*callback)(uint64_t));
  void PrimeSieve::generatePrimes(uint64_t start, uint64_t stop, void (*callback)(uint64_t, int));

  ////////////////////////////////////////////////////////////////////
  // generate_primes.cpp
  // The callback function will be executed for each prime
  // in the interval [2, 1000].

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>

  void callback(unsigned int prime)
  {
    std::cout << prime << ", ";
  }

  int main()
  {
    PrimeSieve ps;
    ps.generatePrimes(2, 1000, callback);
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

3. Generate primes OOP
======================

  If your class is derived from PrimeSieveCallback<T> and implements
  a callback(T) method then you can pass instances of your class to
  one of the generatePrimes() methods below and your callback method
  will be executed for all the primes in the range [start, stop].

  API for prime generation
  ------------------------
  void PrimeSieve::generatePrimes(uint32_t start, uint32_t stop, PrimeSieveCallback<uint32_t>*);
  void PrimeSieve::generatePrimes(uint32_t start, uint32_t stop, PrimeSieveCallback<uint64_t>*);
  void PrimeSieve::generatePrimes(uint32_t start, uint32_t stop, PrimeSieveCallback<uint64_t, int>*);

  ////////////////////////////////////////////////////////////////////
  // store_primes_in_vector2.cpp
  // Instances of classes that derive from PrimeSieveCallback<T>
  // can be passed to the generatePrimes() methods.

  #include <primesieve/soe/PrimeSieve.h>
  #include <primesieve/soe/PrimeSieveCallback.h>
  #include <stdint.h>
  #include <vector>
  #include <iostream>

  template <typename T>
  struct PrimeSieveVector : public std::vector<T>,
                            public PrimeSieveCallback<uint64_t>
  {
    void callback(uint64_t prime)
    {
      this->push_back( static_cast<T>(prime) );
    }
  };

  int main()
  {
    PrimeSieveVector<int> primes;
    PrimeSieve ps;
    ps.generatePrimes(0, 1000, &primes);
    for (std::size_t i = 0; i < primes.size(); i++)
      std::cout << primes[i] << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

4. Count primes
===============

  API for counting
  ----------------
  uint64_t PrimeSieve::countPrimes     (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::countTwins      (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::countTriplets   (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::countQuadruplets(uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::countQuintuplets(uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::countSextuplets (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::countSeptuplets (uint64_t start, uint64_t stop);

  ////////////////////////////////////////////////////////////////////
  // count_primes.cpp
  // Count the primes up to 1000.

  #include <primesieve/soe/PrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main()
  {
    PrimeSieve ps;
    uint64_t count = ps.countPrimes(2, 1000);
    std::cout << "Primes below 1000 = " << count << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

5. Print primes
===============

  API for printing (to std::cout)
  -------------------------------
  void PrimeSieve::printPrimes     (uint64_t start, uint64_t stop);
  void PrimeSieve::printTwins      (uint64_t start, uint64_t stop);
  void PrimeSieve::printTriplets   (uint64_t start, uint64_t stop);
  void PrimeSieve::printQuadruplets(uint64_t start, uint64_t stop);
  void PrimeSieve::printQuintuplets(uint64_t start, uint64_t stop);
  void PrimeSieve::printSextuplets (uint64_t start, uint64_t stop);
  void PrimeSieve::printSeptuplets (uint64_t start, uint64_t stop);

  ////////////////////////////////////////////////////////////////////
  // print_twins.cpp
  // Print the twin primes up to 1000 to std::cout.
  // Program output:
  // (3, 5)
  // (5, 7)
  // ...

  #include <primesieve/soe/PrimeSieve.h>

  int main()
  {
    PrimeSieve ps;
    ps.printTwins(0, 1000);
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

6. ParallelPrimeSieve
=====================

  ParallelPrimeSieve uses OpenMP multi-threading to sieve primes in
  parallel, it scales well even with hundreds of CPU cores! Its main
  use is to count primes and prime k-tuplets, it can also generate
  and print primes and prime k-tuplets in parallel but only in random
  order. The ParallelPrimeSieve class is derived from PrimeSieve so it
  inherits PrimeSieve's API. The following API methods are exclusive
  to ParallelPrimeSieve:

  API
  ---
  void       ParallelPrimeSieve::setNumThreads(int);
  int        ParallelPrimeSieve::getNumThreads() const;
  static int ParallelPrimeSieve::getMaxThreads();

  Threading behavior
  ------------------
  By default ParallelPrimeSieve counts primes and prime k-tuplets
  using all available CPU cores but generates and prints primes and
  prime k-tuplets in arithmetic order using a single thread.
  To generate or print primes in parallel use setNumThreads(int).

  Examples
  --------

  ////////////////////////////////////////////////////////////////////
  // parallel_count.cpp
  // Count the prime triplets within [10^14, 10^14+10^11]
  // using all CPU cores (default).

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main()
  {
    uint64_t start = (uint64_t) 1E14;
    uint64_t stop  = (uint64_t) (1E14+1E11);
    ParallelPrimeSieve pps;
    pps.countTriplets(start, stop);
    std::cout << "Prime triplets in [10^14, 10^14+10^11] = "
              << pps.getTripletCount()
              << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

  Parallel prime number generation (1)
  ------------------------------------
  The generatePrimes() methods that take a callback with 1 parameter
  are synchronized i.e. only 1 thread at a time calls back primes.
  These methods are easy to use but do not scale well beyond 4 CPU
  cores.

  ////////////////////////////////////////////////////////////////////
  // parallel_sum_primes.cpp
  // Sum the primes below 10^10 using 4 threads.

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  uint64_t sum = 0;

  void callback(uint64_t prime) {
    sum += prime;
  }

  int main()
  {
    uint64_t stop = (uint64_t) 1E10;
    ParallelPrimeSieve pps;
    pps.setNumThreads(4);
    pps.generatePrimes(0, stop, callback);
    std::cout << "Sum of the primes below 10^10 = " << sum << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

  Parallel prime number generation (2)
  ------------------------------------
  The generatePrimes() methods that take a callback with 2 parameters
  are not synchronized i.e. multiple threads call back primes in
  parallel. This method scales well even with 100 CPU cores but you
  must pay attention not to write to the same variable from multiple
  threads. In order to get the best performance you must also ensure
  that each thread uses its own cache line for memory access (avoids
  false sharing).

  ////////////////////////////////////////////////////////////////////
  // parallel_sum_primes2.cpp
  // Sum the primes below 10^11 using all CPU cores.

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>
  #include <vector>
  #include <numeric>

  const int THREADS = ParallelPrimeSieve::getMaxThreads();
  const int CACHE_LINE = 256;
  const int NO_FALSE_SHARING = CACHE_LINE / sizeof(uint64_t);

  std::vector<uint64_t> sum;

  void callback(uint64_t prime, int threadNum)
  {
    int threadIndex = threadNum * NO_FALSE_SHARING;
    sum[threadIndex] += prime;
  }

  int main()
  {
    sum.resize(THREADS * NO_FALSE_SHARING, 0);
    ParallelPrimeSieve pps;
    pps.setNumThreads(THREADS);
    pps.generatePrimes(0, (uint64_t) 1E11, callback);
    std::cout << "Sum of the primes below 10^11 = "
              << std::accumulate(sum.begin(), sum.end(), 0ull)
              << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

7. Timing
=========

  API for timing
  --------------
  double PrimeSieve::getSeconds() const;

  ////////////////////////////////////////////////////////////////////
  // timing.cpp
  // getSeconds() returns the time elapsed in seconds.

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>

  int main()
  {
    PrimeSieve ps;
    ps.countPrimes(2, 1000000000);
    std::cout << "Primes below 10^9: " << ps.getPrimeCount()        << std::endl
              << "Time elapsed: "      << ps.getSeconds() << " sec" << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

8. Performance tuning
=====================

  The best sieving performance is achieved if the sieve array fits
  into the CPU's L1 data cache (usually 32 or 64 KB) when
  sieving < 10^17. When sieving >= 10^17 a sieve size of the CPU's L2
  cache size per core (e.g. 512 KB) often performs better.
  PrimeSieve::setSieveSize(int) sets the sieve size in kilobytes,
  the default sieve size is 32 kilobytes.

  API
  ---
  void PrimeSieve::setSieveSize(int sieveSize);

  ////////////////////////////////////////////////////////////////////
  // sieve_size.cpp
  // Set a faster sieve size, for > 10^17 use L2 cache size.

  #include <primesieve/soe/PrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main()
  {
    uint64_t start = (uint64_t) 1E19;
    uint64_t stop  = (uint64_t) (1E19+1E10);
    PrimeSieve ps;
    ps.setSieveSize(512);
    ps.countTwins(start, stop);
    std::cout << "Twin primes in [10^19, 10^19+10^10] = "
              << ps.getTwinCount()
              << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

9. C++ Exceptions
=================

  PrimeSieve and ParallelPrimeSieve objects throw primesieve_error
  exceptions for invalid arguments like start > stop.
  primesieve_error is derived from std::runtime_error, it is defined
  in the primesieve_error.h header file.

  ////////////////////////////////////////////////////////////////////
  // primesieve_error.cpp
  // Catch primesieve_error exceptions, start must be <= stop.

  #include <primesieve/soe/PrimeSieve.h>
  #include <primesieve/soe/primesieve_error.h>
  #include <iostream>

  int main()
  {
    int start = 100;
    int stop = 0;
    try {
      PrimeSieve ps;
      ps.printPrimes(start, stop);
    }
    catch (primesieve_error& e) {
      std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

10. Cancel prime number generation
==================================

  PrimeSieve objects are exception safe so it is possible to throw an
  exception to cancel prime number generation.

  ////////////////////////////////////////////////////////////////////
  // cancel_prime_generation.cpp
  // Cancel prime number generation (callback) by throwing
  // a stop_primesieve() exception.

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>
  #include <exception>
  #include <vector>

  class stop_primesieve : public std::exception { };

  std::vector<int> primes;

  void store(unsigned int prime)
  {
    if (primes.size() == 1000) throw stop_primesieve();
    primes.push_back(prime);
  }

  int main()
  {
    PrimeSieve ps;
    try {
      ps.generatePrimes(0, 999999999, store);
    }
    catch (stop_primesieve&) { }
    std::cout << primes.size() << " primes stored!" << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

11. Flags
=========

  Flags are settings for PrimeSieve and ParallelPrimeSieve objects.
  PrimeSieve flags can be used to do multiple tasks in one go,
  e.g. count primes and twin primes and print the status in percent
  whilst sieving.

  API
  ---
  void PrimeSieve::sieve(uint64_t start, uint64_t stop, int flags);

  Flags
  -----
  PrimeSieve::COUNT_PRIMES
  PrimeSieve::COUNT_TWINS
  PrimeSieve::COUNT_TRIPLETS
  PrimeSieve::COUNT_QUADRUPLETS
  PrimeSieve::COUNT_QUINTUPLETS
  PrimeSieve::COUNT_SEXTUPLETS
  PrimeSieve::COUNT_SEPTUPLETS
  PrimeSieve::PRINT_PRIMES
  PrimeSieve::PRINT_TWINS
  PrimeSieve::PRINT_TRIPLETS
  PrimeSieve::PRINT_QUADRUPLETS
  PrimeSieve::PRINT_QUINTUPLETS
  PrimeSieve::PRINT_SEXTUPLETS
  PrimeSieve::PRINT_SEPTUPLETS
  PrimeSieve::PRINT_STATUS
  PrimeSieve::CALCULATE_STATUS

  ////////////////////////////////////////////////////////////////////
  // flags.cpp
  // Count prime numbers and twin primes using flags.

  #include <primesieve/soe/PrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main()
  {
    PrimeSieve ps;
    int flags = ps.COUNT_PRIMES | ps.COUNT_TWINS | ps.PRINT_STATUS;
    uint64_t start = 0;
    uint64_t stop  = (uint64_t) 1E11;
    ps.sieve(start, stop, flags);
    std::cout << "Primes below 10^11: " << ps.getPrimeCount() << std::endl
              << "Twins  below 10^11: " << ps.getTwinCount()  << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////
