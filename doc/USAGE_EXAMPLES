September 21, 2012
Kim Walisch, <kim.walisch@gmail.com>
http://primesieve.googlecode.com

About
=====

  This file contains C++ source code examples that show how to use
  PrimeSieve and ParallelPrimeSieve objects. Both PrimeSieve and
  ParallelPrimeSieve objects can generate, print (to cout) and count
  primes and prime k-tuplets (twins, triplets, ...).
  For these examples to compile you need to build primesieve as a
  library and add it to the linker, this is explained in the
  LIBPRIMESIEVE file.

Contents
========

  1. Prime number generation
  2. Count primes
  3. Print primes
  4. ParallelPrimeSieve
  5. Timing
  6. Performance tuning
  7. C++ Exceptions
  8. Cancel prime number generation
  9. Flags

1. Prime number generation
==========================

  API for prime number generation
  -------------------------------
  void PrimeSieve::generatePrimes(uint32_t start, uint32_t stop, void (*callback)(uint32_t));
  void PrimeSieve::generatePrimes(uint64_t start, uint64_t stop, void (*callback)(uint64_t));
  void PrimeSieve::generatePrimes(uint32_t start, uint32_t stop, void (*callback)(uint32_t, void*), void*);
  void PrimeSieve::generatePrimes(uint64_t start, uint64_t stop, void (*callback)(uint64_t, void*), void*);

  ////////////////////////////////////////////////////////////////////
  // C-style callback, generate the primes up to 1000
  // and print them to std::cout

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>

  void callback(unsigned int prime) {
    std::cout << prime << '\n';
  }

  int main()
  {
    PrimeSieve ps;
    ps.generatePrimes(2, 1000, callback);
    return 0;
  }

  ////////////////////////////////////////////////////////////////////
  // OOP-style callback, generate the primes up to 1000
  // and store them into the private primes_ vector

  #include <primesieve/soe/PrimeSieve.h>
  #include <vector>

  class Foo {
  public:
    void primes(unsigned int x)
    {
      PrimeSieve ps;
      ps.generatePrimes(0, x, store, (void*) this);
    }
  private:
    std::vector<unsigned int> primes_;
    static void store(unsigned int prime, void* obj)
    {
      Foo* f = (Foo*) obj;
      f->primes_.push_back(prime);
    }
  };

  int main()
  {
    Foo foo;
    foo.primes(1000);
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

2. Count primes
===============

  API for counting
  ----------------
  uint64_t PrimeSieve::getPrimeCount     (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getTwinCount      (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getTripletCount   (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getQuadrupletCount(uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getQuintupletCount(uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getSextupletCount (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getSeptupletCount (uint64_t start, uint64_t stop);

  ////////////////////////////////////////////////////////////////////
  // Count the primes up to 1000

  #include <primesieve/soe/PrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main()
  {
    PrimeSieve ps;
    uint64_t count = ps.getPrimeCount(2, 1000);
    std::cout << "Prime count: " << count << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

3. Print primes
===============

  API for printing (to std::cout)
  -------------------------------
  void PrimeSieve::printPrimes     (uint64_t start, uint64_t stop);
  void PrimeSieve::printTwins      (uint64_t start, uint64_t stop);
  void PrimeSieve::printTriplets   (uint64_t start, uint64_t stop);
  void PrimeSieve::printQuadruplets(uint64_t start, uint64_t stop);
  void PrimeSieve::printQuintuplets(uint64_t start, uint64_t stop);
  void PrimeSieve::printSextuplets (uint64_t start, uint64_t stop);
  void PrimeSieve::printSeptuplets (uint64_t start, uint64_t stop);

  ////////////////////////////////////////////////////////////////////
  // Print the twin primes up to 1000 to std::cout
  // Program output:
  // (3, 5)
  // (5, 7)
  // ...

  #include <primesieve/soe/PrimeSieve.h>

  int main()
  {
    PrimeSieve ps;
    ps.printTwins(0, 1000);
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

4. ParallelPrimeSieve
=====================

  ParallelPrimeSieve uses OpenMP multi-threading to sieve primes in
  parallel. It scales well even with hundreds of CPU cores! Its main
  use is to count primes and prime k-tuplets, it can also generate
  and print primes and prime k-tuplets in parallel but only in random
  order.

  The ParallelPrimeSieve class is derived from PrimeSieve so it
  inherits PrimeSieve's API. The following API methods are exclusive
  to ParallelPrimeSieve:

  API
  ---
  void       ParallelPrimeSieve::setNumThreads(int);
  int        ParallelPrimeSieve::getNumThreads() const;
  static int ParallelPrimeSieve::getMaxThreads();
  void       ParallelPrimeSieve::generatePrimes(uint64_t start, uint64_t stop, void (*callback)(uint64_t, int));

  Threading behavior
  ------------------
  By default ParallelPrimeSieve counts primes and prime k-tuplets
  using all available CPU cores but generates and prints primes and
  prime k-tuplets in arithmetic order using a single thread.
  To generate or print primes in parallel use setNumThreads(int).

  Examples
  --------

  ////////////////////////////////////////////////////////////////////
  // Count the prime triplets within [10^14, 10^14+10^11]
  // using all CPU cores (default)

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main()
  {
    ParallelPrimeSieve pps;
    uint64_t start = (uint64_t) 1E14;
    uint64_t stop  = (uint64_t) (1E14+1E11);
    uint64_t count = pps.getTripletCount(start, stop);
    std::cout << "Prime triplet count: " << count << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

  Synchronized prime number generation
  ------------------------------------
  The four generatePrimes(...) methods from (1.) are synchronized i.e.
  only one thread at a time calls back primes. These methods are easy
  to use but do not scale well beyond 4 CPU cores.

  ////////////////////////////////////////////////////////////////////
  // Sum the primes below 10^10 using 4 threads

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  uint64_t sum = 0;

  void callback(uint64_t prime) {
    sum += prime;
  }

  int main()
  {
    ParallelPrimeSieve pps;
    pps.setNumThreads(4);
    pps.generatePrimes(0, (uint64_t) 1E10, callback);
    std::cout << "Sum of the primes below 10^10 = " << sum << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

  Unsynchronized prime number generation
  --------------------------------------
  ParallelPrimeSieve's generatePrimes(...) method is not synchronized,
  it scales well even with a hundred CPU cores but it is a little
  harder to use: You must pay attention not to write to (or read from
  and write to) the same variable from multiple threads, for a good
  performance it is also important that multiple threads do not share
  the same cache line (see below).

  ////////////////////////////////////////////////////////////////////
  // Sum the primes below 10^11 using 100 threads

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>
  #include <vector>
  #include <numeric>

  const int CACHE_LINE = 128;
  const int NO_FALSE_SHARING = CACHE_LINE / sizeof(uint64_t);

  std::vector<uint64_t> sum;

  void callback(uint64_t prime, int threadNumber)
  {
    int threadIndex = threadNumber * NO_FALSE_SHARING;
    sum[threadIndex] += prime;
  }

  int main()
  {
    const int THREADS = 100;
    sum.resize(THREADS * NO_FALSE_SHARING, 0);
    ParallelPrimeSieve pps;
    pps.setNumThreads(THREADS);
    pps.generatePrimes(0, (uint64_t) 1E11, callback);
    std::cout << std::accumulate(sum.begin(), sum.end(), 0ull) << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

5. Timing
=========

  API for timing
  --------------
  double PrimeSieve::getSeconds() const;

  ////////////////////////////////////////////////////////////////////
  // getSeconds() returns the time elapsed in seconds

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main()
  {
    ParallelPrimeSieve pps;
    uint64_t count = pps.getPrimeCount(2, 1000000000);
    double seconds = pps.getSeconds();
    std::cout << "Prime count: " << count << std::endl
              << "Time elapsed: " << seconds << " sec" << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

6. Performance tuning
=====================

  The best sieving performance is achieved if the sieve array fits
  into the CPU's L1 data cache (usually 32 or 64 KB) when
  sieving < 10^17. When sieving >= 10^17 a sieve size of the CPU's L2
  cache size per core (e.g. 512 KB) often performs better.
  PrimeSieve::setSieveSize(int) sets the sieve size in kilobytes,
  the default sieve size is 32 kilobytes.

  API
  ---
  void PrimeSieve::setSieveSize(int sieveSize);

  ////////////////////////////////////////////////////////////////////
  // Set a faster sieve size, for > 10^17 use L2 cache size

  #include <primesieve/soe/PrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main()
  {
    PrimeSieve ps;
    ps.setSieveSize(512);
    uint64_t start = (uint64_t) 1E19;
    uint64_t stop  = (uint64_t) (1E19+1E10);
    std::cout << ps.getPrimeCount(start, stop) << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

7. C++ Exceptions
=================

  PrimeSieve and ParallelPrimeSieve objects throw primesieve_error
  exceptions for invalid arguments like start > stop.
  primesieve_error is defined in PrimeSieve.h and derived from
  std::runtime_error.

  ////////////////////////////////////////////////////////////////////
  // Catch primesieve_error exceptions

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>

  int main()
  {
    int start = 100;
    int stop = 0;
    try {
      PrimeSieve ps;
      ps.printPrimes(start, stop);
    }
    catch (primesieve_error& e) {
      std::cerr << "Error: " << e.what() << std::endl;
    }
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

8. Cancel prime number generation
=================================

  PrimeSieve objects are exception safe so it is possible to throw an
  exception to cancel prime number generation.

  ////////////////////////////////////////////////////////////////////
  // Store the first 1000 primes in a vector

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>
  #include <exception>
  #include <vector>

  std::vector<unsigned int> primes;

  void store(unsigned int prime)
  {
    if (primes.size() == 1000) throw std::exception();
    primes.push_back(prime);
  }

  int main()
  {
    PrimeSieve ps;
    try {
      ps.generatePrimes(0, 999999, store);
    }
    catch (std::exception&) { }
    for (unsigned i = 0; i < primes.size(); i++)
      std::cout << primes[i] << '\n';
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

9. Flags
========

  Flags are settings for PrimeSieve and ParallelPrimeSieve objects,
  they are set using setFlags(int), when done sieve() starts sieving.
  PrimeSieve flags can be used to do multiple tasks in one go,
  e.g. count primes and twin primes and print the status in percent
  whilst sieving.

  API
  ---
  void PrimeSieve::setFlags(int);

  Flags
  -----
  PrimeSieve::COUNT_PRIMES
  PrimeSieve::COUNT_TWINS
  PrimeSieve::COUNT_TRIPLETS
  PrimeSieve::COUNT_QUADRUPLETS
  PrimeSieve::COUNT_QUINTUPLETS
  PrimeSieve::COUNT_SEXTUPLETS
  PrimeSieve::COUNT_SEPTUPLETS
  PrimeSieve::PRINT_PRIMES
  PrimeSieve::PRINT_TWINS
  PrimeSieve::PRINT_TRIPLETS
  PrimeSieve::PRINT_QUADRUPLETS
  PrimeSieve::PRINT_QUINTUPLETS
  PrimeSieve::PRINT_SEXTUPLETS
  PrimeSieve::PRINT_SEPTUPLETS
  PrimeSieve::PRINT_STATUS
  PrimeSieve::CALCULATE_STATUS

  ////////////////////////////////////////////////////////////////////
  // Count prime numbers and twin primes using flags

  #include <primesieve/soe/PrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main()
  {
    PrimeSieve ps;
    ps.setFlags(ps.COUNT_PRIMES | ps.COUNT_TWINS | ps.PRINT_STATUS);
    ps.sieve(0, (uint64_t) 1E11);
    // print the previously calculated count results
    std::cout << ps.getPrimeCount() << std::endl
              << ps.getTwinCount()  << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////
