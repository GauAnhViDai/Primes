August 24, 2012
Kim Walisch, <kim.walisch@gmail.com>
http://primesieve.googlecode.com

About
=====

  This file contains C++ source code examples that show how to use
  PrimeSieve and ParallelPrimeSieve objects. Both PrimeSieve and
  ParallelPrimeSieve objects can generate, print (to cout) and count
  primes and prime k-tuplets (twins, triplets, ...).
  For these examples to compile you need to build primesieve as a
  library and add it to the linker, this is explained in the
  LIBPRIMESIEVE file.

Contents
========

  1. Prime number generation
  2. Count primes
  3. Print primes
  4. ParallelPrimeSieve
  5. Timing
  6. Performance tuning
  7. Cancel prime number generation
  8. Flags

1. Prime number generation
==========================

  API for prime number generation
  -------------------------------
  void PrimeSieve::generatePrimes(uint32_t start, uint32_t stop, void (*callback)(uint32_t));
  void PrimeSieve::generatePrimes(uint64_t start, uint64_t stop, void (*callback)(uint64_t));
  void PrimeSieve::generatePrimes(uint32_t start, uint32_t stop, void (*callback)(uint32_t, void*), void*);
  void PrimeSieve::generatePrimes(uint64_t start, uint64_t stop, void (*callback)(uint64_t, void*), void*);

  ////////////////////////////////////////////////////////////////////
  // C-style callback, generate the primes up to 1000
  // and print them to the standard output

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>

  void callback(unsigned int prime) {
    std::cout << prime << '\n';
  }

  int main() {
    PrimeSieve ps;
    ps.generatePrimes(2, 1000, callback);
    return 0;
  }

  ////////////////////////////////////////////////////////////////////
  // OOP-style callback, generate the primes up to 1000
  // and store them into the private primes_ vector

  #include <primesieve/soe/PrimeSieve.h>
  #include <vector>

  class Foo {
  public:
    void primes(unsigned int x) {
      PrimeSieve ps;
      ps.generatePrimes(0, x, store, (void*) this);
    }
  private:
    std::vector<unsigned int> primes_;
    static void store(unsigned int prime, void* obj) {
      Foo* f = (Foo*) obj;
      f->primes_.push_back(prime);
    }
  };

  int main() {
    Foo foo;
    foo.primes(1000);
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

2. Count primes
===============

  API for counting
  ----------------
  uint64_t PrimeSieve::getPrimeCount     (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getTwinCount      (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getTripletCount   (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getQuadrupletCount(uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getQuintupletCount(uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getSextupletCount (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getSeptupletCount (uint64_t start, uint64_t stop);

  ////////////////////////////////////////////////////////////////////
  // Count the primes up to 1000

  #include <primesieve/soe/PrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main() {
    PrimeSieve ps;
    uint64_t count = ps.getPrimeCount(2, 1000);
    std::cout << "prime count: " << count << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

3. Print primes
===============

  API for printing (to std::cout)
  -------------------------------
  void PrimeSieve::printPrimes     (uint64_t start, uint64_t stop);
  void PrimeSieve::printTwins      (uint64_t start, uint64_t stop);
  void PrimeSieve::printTriplets   (uint64_t start, uint64_t stop);
  void PrimeSieve::printQuadruplets(uint64_t start, uint64_t stop);
  void PrimeSieve::printQuintuplets(uint64_t start, uint64_t stop);
  void PrimeSieve::printSextuplets (uint64_t start, uint64_t stop);
  void PrimeSieve::printSeptuplets (uint64_t start, uint64_t stop);

  ////////////////////////////////////////////////////////////////////
  // Print the twin primes up to 1000 to std::cout
  // Program output:
  // (3, 5)
  // (5, 7)
  // ...

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>

  int main() {
    PrimeSieve ps;
    ps.printTwins(0, 1000);
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

4. ParallelPrimeSieve
=====================

  ParallelPrimeSieve uses OpenMP multi-threading to sieve primes in
  parallel. Its main use is to count primes and prime k-tuplets, it
  can also generate and print primes and k-tuplets in parallel but
  only in random order. The ParallelPrimeSieve class is derived from
  PrimeSieve so it has the same API. 

  Note: by default ParallelPrimeSieve counts primes in parallel using
  multiple threads but generates and prints primes in arithmetic
  order using a single thread.

  API
  ---
  void       ParallelPrimeSieve::setNumThreads(int);
  static int ParallelPrimeSieve::getMaxThreads();
  int        ParallelPrimeSieve::getNumThreads() const;

  ////////////////////////////////////////////////////////////////////
  // Count the prime triplets within [10^14, 10^14+10^11]
  // using all CPU cores (default)

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main() {
    ParallelPrimeSieve pps;
    uint64_t start = (uint64_t) 1E14;
    uint64_t stop  = (uint64_t) (1E14+1E11);
    uint64_t count = pps.getTripletCount(start, stop);
    std::cout << "prime triplet count: " << count << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////
  // Sum the primes below 10^10 using 4 threads.
  // Note: prime number generation is synchronized i.e. only one
  // thread at a time calls back primes.

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  uint64_t sum = 0;

  void callback(uint64_t prime) {
    sum += prime;
  }

  int main() {
    ParallelPrimeSieve pps;
    pps.setNumThreads(4);
    pps.generatePrimes(0, (uint64_t) 1E10, callback);
    std::cout << "Sum of the primes below 10^10 = " << sum << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

5. Timing
=========

  API for timing
  --------------
  double PrimeSieve::getSeconds() const;

  ////////////////////////////////////////////////////////////////////
  // getSeconds() returns the time elapsed in seconds

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main() {
    ParallelPrimeSieve pps;
    uint64_t count = pps.getPrimeCount(2, 4294967295U);
    double seconds = pps.getSeconds();
    std::cout << "prime count: "  << count             << std::endl
              << "time elapsed: " << seconds << " sec" << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

6. Performance tuning
=====================

  The best sieving performance is achieved with a sieve size of the
  CPU's L1 data cache size per core (usually 32 or 64 KB) when
  sieving < 10^17 and a sieve size of the CPU's L2 cache size per core
  e.g. 512 KB above. The default sieve size is 32 kilobytes.

  API
  ---
  void PrimeSieve::setSieveSize(int);

  ////////////////////////////////////////////////////////////////////
  // Set a faster sieve size, for > 10^17 use L2 cache size

  #include <primesieve/soe/PrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main() {
    PrimeSieve ps;
    ps.setSieveSize(512);
    uint64_t start = (uint64_t) 1E19;
    uint64_t stop  = (uint64_t) (1E19+1E10);
    uint64_t count = ps.getPrimeCount(start, stop);
    double seconds = ps.getSeconds();
    std::cout << "prime count: "  << count             << std::endl
              << "time elapsed: " << seconds << " sec" << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

7. Cancel prime number generation
=================================

  PrimeSieve objects are exception safe so it is possible to throw an
  exception to cancel sieving. The following trial-division prime
  number checker cancels prime number generation if 'candidate' is not
  a prime by throwing an exception.

  ////////////////////////////////////////////////////////////////////

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>
  #include <cstdlib>
  #include <cmath>

  unsigned int candidate;

  void check(unsigned int prime) {
    if (candidate % prime == 0) throw std::exception();
  }

  int main(int argc, char* argv[]) {
    bool isPrime = false;
    candidate = atoi(argv[1]);

    if (candidate > 1) {
      unsigned int sq = (unsigned int) std::sqrt((double) candidate);
      try {
        PrimeSieve ps;
        ps.generatePrimes(0, sq, check);
        isPrime = true;
      } catch (...) { }
    }
    std::cout << candidate << " is "
              << (isPrime ? "a prime" : "not a prime")
              << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

8. Flags
========

  Flags are settings for PrimeSieve and ParallelPrimeSieve objects,
  they are set using setFlags(int), when done sieve() starts sieving.
  Flags allow to do multiple tasks in one go e.g. count prime numbers
  and twin primes and print the status in percent whilst sieving.

  API
  ---
  void PrimeSieve::setFlags(int flags);

  Flags
  -----
  PrimeSieve::COUNT_PRIMES
  PrimeSieve::COUNT_TWINS
  PrimeSieve::COUNT_TRIPLETS
  PrimeSieve::COUNT_QUADRUPLETS
  PrimeSieve::COUNT_QUINTUPLETS
  PrimeSieve::COUNT_SEXTUPLETS
  PrimeSieve::COUNT_SEPTUPLETS
  PrimeSieve::PRINT_PRIMES
  PrimeSieve::PRINT_TWINS
  PrimeSieve::PRINT_TRIPLETS
  PrimeSieve::PRINT_QUADRUPLETS
  PrimeSieve::PRINT_QUINTUPLETS
  PrimeSieve::PRINT_SEXTUPLETS
  PrimeSieve::PRINT_SEPTUPLETS
  PrimeSieve::CALCULATE_STATUS
  PrimeSieve::PRINT_STATUS

  ////////////////////////////////////////////////////////////////////
  // Count prime numbers and twin primes in one go
  // and print the status whilst sieving

  #include <primesieve/soe/PrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main() {
    uint64_t start = 0;
    uint64_t stop = (uint64_t) 1E11;
    PrimeSieve ps;
    ps.setFlags(ps.COUNT_PRIMES | ps.COUNT_TWINS | ps.PRINT_STATUS);
    ps.sieve(start, stop);
    // get the previously calculated count results
    uint64_t pcount = ps.getPrimeCount();
    uint64_t tcount = ps.getTwinCount();
    std::cout << "\nprime count: " << pcount << std::endl
              << "twin count:  "   << tcount << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////
