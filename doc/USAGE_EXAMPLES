June 12, 2012
Kim Walisch, <kim.walisch@gmail.com>
http://primesieve.googlecode.com

About
=====

  This file contains C++ source code examples that show how to use
  PrimeSieve and ParallelPrimeSieve objects. *PrimeSieve objects can
  generate (callback), print and count primes and prime k-tuplets
  (twins, triplets, ...). For these examples to compile you need to
  build primesieve as a library and add it to the linker, this is
  explained in the LIBPRIMESIEVE file.

Contents
========

  1. Prime number generation
  2. Count primes
  3. Print primes
  4. ParallelPrimeSieve
  5. Timing
  6. Performance tuning
  7. Cancel prime number generation
  8. Setting flags

1. Prime number generation
==========================

  API for prime number generation
  -------------------------------
  void PrimeSieve::generatePrimes(uint32_t start, uint32_t stop, void (*callback)(uint32_t));
  void PrimeSieve::generatePrimes(uint64_t start, uint64_t stop, void (*callback)(uint64_t));
  void PrimeSieve::generatePrimes(uint32_t start, uint32_t stop, void (*callback)(uint32_t, void*), void*);
  void PrimeSieve::generatePrimes(uint64_t start, uint64_t stop, void (*callback)(uint64_t, void*), void*);

  ////////////////////////////////////////////////////////////////////
  // C-style callback, generate the primes up to 1000
  // and print them to the standard output

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>

  void print(unsigned int prime) {
    std::cout << prime << '\n';
  }

  int main() {
    PrimeSieve ps;
    ps.generatePrimes(2, 1000, print);
    return 0;
  }

  ////////////////////////////////////////////////////////////////////
  // OOP-style callback, generate the primes up to 1000
  // and store them into the private primes_ vector

  #include <primesieve/soe/PrimeSieve.h>
  #include <vector>

  class Foo {
  public:
    void primes(unsigned int x) {
      PrimeSieve ps;
      ps.generatePrimes(0, x, store, (void*) this);
    }
  private:
    std::vector<unsigned int> primes_;
    static void store(unsigned int prime, void* obj) {
      Foo* f = (Foo*) obj;
      f->primes_.push_back(prime);
    }
  };

  int main() {
    Foo foo;
    foo.primes(1000);
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

2. Count primes
===============

  API for counting
  ----------------
  uint64_t PrimeSieve::getPrimeCount     (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getTwinCount      (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getTripletCount   (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getQuadrupletCount(uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getQuintupletCount(uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getSextupletCount (uint64_t start, uint64_t stop);
  uint64_t PrimeSieve::getSeptupletCount (uint64_t start, uint64_t stop);

  ////////////////////////////////////////////////////////////////////
  // Count the primes up to 1000

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>

  int main() {
    PrimeSieve ps;
    std::cout << "prime count: " << ps.getPrimeCount(2, 1000) << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

3. Print primes
===============

  API for printing (to std::cout)
  -------------------------------
  void PrimeSieve::printPrimes     (uint64_t start, uint64_t stop);
  void PrimeSieve::printTwins      (uint64_t start, uint64_t stop);
  void PrimeSieve::printTriplets   (uint64_t start, uint64_t stop);
  void PrimeSieve::printQuadruplets(uint64_t start, uint64_t stop);
  void PrimeSieve::printQuintuplets(uint64_t start, uint64_t stop);
  void PrimeSieve::printSextuplets (uint64_t start, uint64_t stop);
  void PrimeSieve::printSeptuplets (uint64_t start, uint64_t stop);

  ////////////////////////////////////////////////////////////////////
  // Print the twin primes up to 1000 to std::cout
  // Program output:
  // (3, 5)
  // (5, 7)
  // ...

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>

  int main() {
    PrimeSieve ps;
    ps.printTwins(0, 1000);
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

4. ParallelPrimeSieve
=====================

  The ParallelPrimeSieve class is derived from PrimeSieve thus it has
  the same API but it uses OpenMP multi-threading to sieve primes in
  parallel. Its main use is to count primes and prime k-tuplets, it
  can also generate and print primes and k-tuplets in parallel but
  only in random order.

  Note: by default ParallelPrimeSieve counts primes and k-tuplets in
  parallel using multiple threads but generates and prints primes and
  k-tuplets in arithmetic order using a single thread.

  ////////////////////////////////////////////////////////////////////
  // Count the prime triplets within [10^14, 10^14+10^11]
  // using all CPU cores

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main() {
    ParallelPrimeSieve pps;
    uint64_t start = (uint64_t) 1E14;
    uint64_t stop = (uint64_t) (1E14+1E11);
    std::cout << "prime triplet count: " << pps.getTripletCount(start, stop) << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////
  // Sum the primes below 10^10 using 4 threads

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  uint64_t sum = 0;

  void sumPrimes(uint64_t prime) {
    sum += prime;
  }

  int main() {
    uint64_t stop = (uint64_t) 1E10;
    ParallelPrimeSieve pps;
    pps.setNumThreads(4);
    pps.generatePrimes(0, stop, sumPrimes);
    std::cout << "Sum of the primes below 10^10 = " << sum << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

5. Timing
=========

  API for timing
  --------------
  double PrimeSieve::getSeconds() const;

  ////////////////////////////////////////////////////////////////////
  // getSeconds() returns the time elapsed in seconds
  // Program output:
  // prime count: 203280221
  // time elapsed: 0.471 sec

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <iostream>

  int main() {
    ParallelPrimeSieve pps;
    std::cout << "prime count: "  << pps.getPrimeCount(2, 4294967295U) << std::endl
              << "time elapsed: " << pps.getSeconds() << " sec"        << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

6. Performance tuning
=====================

  The best sieving performance is achieved with a sieve size of the
  CPU's L1 data cache size (usually 32 or 64 KB) when sieving < 10^16
  and a sieve size of the CPU's L2 cache size per core e.g. 512 KB
  above. The default sieve size is 32 kilobytes.

  ////////////////////////////////////////////////////////////////////
  // Set a faster sieve size

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>

  int main() {
    PrimeSieve ps;
    ps.setSieveSize(512);
    uint64_t start = (uint64_t) 1E19;
    uint64_t stop = (uint64_t) (1E19+1E10);
    std::cout << "prime count: "  << ps.getPrimeCount(start, stop) << std::endl
              << "time elapsed: " << ps.getSeconds() << " sec"     << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

7. Cancel prime number generation
=================================

  PrimeSieve objects are exception safe so it is possible to throw an
  exception to cancel sieving. The following trial-division prime
  number checker cancels prime number generation if 'candidate' is not
  a prime by throwing a cancel_sieving() exception.

  ////////////////////////////////////////////////////////////////////

  #include <primesieve/soe/PrimeSieve.h>
  #include <iostream>
  #include <cstdlib>
  #include <cmath>

  unsigned int candidate;

  void check(unsigned int prime) {
    if (candidate % prime == 0) throw cancel_sieving();
  }

  int main(int argc, char* argv[]) {
    candidate = strtoul(argv[1], NULL, 10);
    bool isPrime = false;

    if (candidate > 1) {
      unsigned int limit = (unsigned int) std::sqrt((double) candidate);
      PrimeSieve ps;
      try {
        ps.generatePrimes(0, limit, check);
        isPrime = true;
      }
      catch (...) { }
    }
    std::cout << candidate << " is "
              << (isPrime ? "a prime" : "not a prime")
              << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////

8. Setting flags
================

  Counting and printing can also be done using flags, this allows
  for instance to count prime numbers and twin primes in one go or to
  print the status in percent whilst sieving.

  API
  ---
  void PrimeSieve::setFlags(int flags);

  Flags
  -----
  PrimeSieve::COUNT_PRIMES
  PrimeSieve::COUNT_TWINS
  PrimeSieve::COUNT_TRIPLETS
  PrimeSieve::COUNT_QUADRUPLETS
  PrimeSieve::COUNT_QUINTUPLETS
  PrimeSieve::COUNT_SEXTUPLETS
  PrimeSieve::COUNT_SEPTUPLETS
  PrimeSieve::PRINT_PRIMES
  PrimeSieve::PRINT_TWINS
  PrimeSieve::PRINT_TRIPLETS
  PrimeSieve::PRINT_QUADRUPLETS
  PrimeSieve::PRINT_QUINTUPLETS
  PrimeSieve::PRINT_SEXTUPLETS
  PrimeSieve::PRINT_SEPTUPLETS
  PrimeSieve::CALCULATE_STATUS
  PrimeSieve::PRINT_STATUS

  ////////////////////////////////////////////////////////////////////
  // Count prime numbers and twin primes in one go
  // and print the status whilst sieving

  #include <primesieve/soe/ParallelPrimeSieve.h>
  #include <stdint.h>
  #include <iostream>

  int main() {
    uint64_t start = 0;
    uint64_t stop = (uint64_t) 1E11;
    ParallelPrimeSieve pps;
    pps.setFlags(pps.COUNT_PRIMES | pps.COUNT_TWINS | pps.PRINT_STATUS);
    pps.sieve(start, stop);
    std::cout << "\nprime count: " << pps.getPrimeCount() << std::endl
              << "twin count:  "   << pps.getTwinCount()  << std::endl;
    return 0;
  }

  ////////////////////////////////////////////////////////////////////
