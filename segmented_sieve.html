<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Simple implementation of the segmented sieve of Eratosthenes (in C++) with explanation of how it works.">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <link rel="stylesheet" type="text/css" href="stylesheets/navigation_menu.css">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>primesieve - Segmented sieve of Eratosthenes</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>primesieve</h1>
        <h2>Fast C/C++ prime number generator</h2>
        <a href="https://github.com/kimwalisch/primesieve" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">

<div id="container">
  <nav id="navigation">
    <ul>
      <li><a href=".">Home</a></li>
      <li><a href="downloads">Downloads</a></li>
      <li><a href="build.html">Build From Source</a></li>
      <li><a href="segmented_sieve.html">Segmented Sieve</a></li>
      <li><a href="api">API Documentation</a></li>
      <li><a href="links.html">Links</a></li>
    </ul>
  </nav>
</div>

<h2>
<a name="about" class="anchor" href="#about"><span class="octicon octicon-link"></span></a>Segmented sieve of Eratosthenes</h2>
<p>Further down is a simple C++ implementation of the segmented sieve
of Eratosthenes that generates the primes below n using
<img src="images/Onloglogn.svg" alt="O(n log log n)" class="formula"/>
operations and
<img src="images/Osqrtn.svg" alt="O(sqrt(n))" class="formula"/>
space. It runs significantly faster than a
<a href="http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Implementation">traditional
sieve of Eratosthenes implementation</a> due to its more efficient
CPU cache usage i.e. it uses the CPU's L1 data cache size as its sieve
array size. This ensures that less than 2 percent of the memory
accesses will be cache misses. This implementation generates the
primes below 10^9 in just 0.9 seconds (single-threaded) on an Intel
Core i7-4770 3.4GHz CPU from 2013.</p>

</p>Any code on this page is free software released into the public
domain. At the end of each code section, you will find instructions on
how to download, compile and run the implementations.<p>

<h2>
<a name="how" class="anchor" href="#how"><span class="octicon octicon-link"></span></a>How it works</h2>
<p>Suppose we want to sieve the primes below 10^9. We chose the size
of the sieve array (named segment_size) to be the same size as the CPU's L1
data cache size per core e.g. 32768 bytes. We first generate the
sieving primes below sqrt(10^9) which are needed to cross-off
multiples. Then we start crossing-off the multiples of the first prime
2 until we reach a multiple of 2&nbsp;&gt;=&nbsp;segment_size, if this
happens we calculate the index of that multiple in the next segment
using (multiple&nbsp;-&nbsp;segment_size) and store it in a separate
array (next[]). We then cross-off the multiples of the next sieving
primes using the same procedure. Once we have crossed-off the multiples
of all sieving primes in the first segment we iterate over the sieve array
and print out (or count) the primes.</p>

<p>In order to sieve the next segment we reset the sieve array and we
increment the lower offset by segment_size. Then we start
crossing-off multiples again, for each sieving prime we retrieve the
sieve index from the next array and we start crossing-off multiples
from there on...</p>

<div class="highlight highlight-C++"><pre><span class="c1">/// Generate primes using the segmented sieve of Eratosthenes.</span>
<span class="c1">/// This algorithm uses O(n log log n) operations and O(sqrt(n)) space.</span>
<span class="c1">/// @param limit         Sieve primes &lt;= limit.</span>
<span class="c1">/// @param segment_size  Size of the sieve array in bytes.</span>
<span class="c1">///</span>
<span class="kt">void</span> <span class="nf">segmented_sieve</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">limit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">segment_size</span> <span class="o">=</span> <span class="n">L1D_CACHE_SIZE</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sqrt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">limit</span><span class="p">);</span>
  <span class="kt">int64_t</span> <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="c1">// vector used for sieving</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">sieve</span><span class="p">(</span><span class="n">segment_size</span><span class="p">);</span>

  <span class="c1">// generate small primes &lt;= sqrt</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">sqrt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">sqrt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">sqrt</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">is_prime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">primes</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">low</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">low</span> <span class="o">+=</span> <span class="n">segment_size</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">sieve</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sieve</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// current segment = interval [low, high]</span>
    <span class="kt">int64_t</span> <span class="n">high</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">segment_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>

    <span class="c1">// store small primes needed to cross off multiples</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">s</span> <span class="o">*</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">is_prime</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
      <span class="p">{</span>
        <span class="n">primes</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">s</span><span class="p">);</span>
          <span class="n">next</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">s</span> <span class="o">*</span> <span class="n">s</span> <span class="o">-</span> <span class="n">low</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// sieve the current segment</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">primes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">primes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">segment_size</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">sieve</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">segment_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">sieve</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">low</span><span class="p">]) <span class="c1">// n is a prime</span></span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">" primes found."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h2>
<a name="build-and-run" class="anchor" href="#build-and-run"><span class="octicon octicon-link"></span></a>How to run it</h2>
<p>Download <a href="segmented_sieve.cpp">segmented_sieve.cpp</a>, open a terminal and run:</p>
<div class="highlight highlight-bash"><pre><span class="c"># Compile using default C++ compiler</span>
<span class="nv">$ </span>c++ -O2 segmented_sieve.cpp -o segmented_sieve

<span class="c"># Count the primes below 10^9 using a segment size of 32 kilobytes</span>
<span class="nv">$ </span>time ./segmented_sieve <span class="k">$((</span><span class="m">10</span><span class="o">**</span><span class="m">9</span><span class="k">))</span> 32768
</pre></div>

<h2>
<a name="using-a-bit-array" class="anchor" href="#using-a-bit-array"><span class="octicon octicon-link"></span></a>Using a bit array</h2>

<p>One issue with the segmented sieve of Eratosthenes when sieving the
primes below n is that the performance and run-time complexity
deteriorate if the segment size is smaller than
<img src="images/sqrtn.svg" alt="sqrt(n)" class="formula"/>.
But ideally one wants to use a sieve array size that matches the CPU's
L1 data cache size. By using a bit array it is possible to use a
larger segment size without changing the sieve array size. Below is an
implementation of the segmented sieve of Eratosthenes which uses a bit
array with 16 numbers per byte for sieving. Each bit corresponds to an
odd integer, the bits of the i-th byte correspond to the numbers
(i * 16) + k, with k = { 1, 3, 5, 7, 9, 11, 13, 15 }. This
implementation runs at least twice as fast as the segmented byte sieve
(further up) when sieving up to 10^11 because the latter's performance
deteriorates above 10^9.</p>

<div class="highlight highlight-C++"><pre><span class="c1">/// Generate primes using the segmented sieve of Eratosthenes.</span>
<span class="c1">/// This implementation uses a bit array with 16 numbers per byte.</span>
<span class="c1">/// @param limit       Sieve primes &lt;= limit.</span>
<span class="c1">/// @param sieve_size  Size of the sieve array in bytes.</span>
<span class="c1">///</span>
<span class="kt">void</span> <span class="nf">segmented_bit_sieve</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">limit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sieve_size</span> <span class="o">=</span> <span class="n">L1D_CACHE_SIZE</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">segment_size</span> <span class="o">=</span> <span class="n">sieve_size</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sqrt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">limit</span><span class="p">);</span>
  <span class="kt">int64_t</span> <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">limit</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// vector used for sieving</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">sieve</span><span class="p">(</span><span class="n">sieve_size</span><span class="p">);</span>

  <span class="c1">// generate small primes &lt;= sqrt</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">sqrt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">sqrt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">sqrt</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">is_prime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">primes</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">low</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">low</span> <span class="o">+=</span> <span class="n">segment_size</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">sieve</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sieve</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mh">0xff</span><span class="p">);</span>

    <span class="c1">// unset bits &gt; limit</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">segment_size</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">)</span>
      <span class="n">sieve</span><span class="p">[(</span><span class="n">limit</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mh">0xff</span> <span class="o">&lt;&lt;</span> <span class="p">((</span><span class="n">limit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">16</span> <span class="o">/</span> <span class="mi">2</span><span class="p">));</span>

    <span class="c1">// current segment = interval [low, high]</span>
    <span class="kt">int64_t</span> <span class="n">high</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">segment_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>

    <span class="c1">// store small primes needed to cross off multiples</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">s</span> <span class="o">*</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">is_prime</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
      <span class="p">{</span>
        <span class="n">primes</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">s</span><span class="p">);</span>
          <span class="n">next</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">s</span> <span class="o">*</span> <span class="n">s</span> <span class="o">-</span> <span class="n">low</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// sieve the current segment</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">primes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">primes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">segment_size</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">sieve</span><span class="p">[</span><span class="n">j</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="n">unset_bit</span><span class="p">[</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">];</span>
      <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">segment_size</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">4</span><span class="p">)</span>
      <span class="n">count</span> <span class="o">+=</span> <span class="n">popcnt</span><span class="p">[</span><span class="n">sieve</span><span class="p">[(</span><span class="n">n</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">]];</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">" primes found."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h2>
<a name="build-and-run" class="anchor" href="#build-and-run"><span class="octicon octicon-link"></span></a>How to run it</h2>
<p>Download <a href="segmented_bit_sieve.cpp">segmented_bit_sieve.cpp</a>, open a terminal and run:</p>
<div class="highlight highlight-bash"><pre><span class="c"># Compile using default C++ compiler</span>
<span class="nv">$ </span>c++ -O2 segmented_bit_sieve.cpp -o segmented_bit_sieve

<span class="c"># Count the primes below 10^10 using a segment size of 32 kilobytes</span>
<span class="nv">$ </span>time ./segmented_bit_sieve <span class="k">$((</span><span class="m">10</span><span class="o">**</span><span class="m">10</span><span class="k">))</span> 32768
</pre></div>

        </section>

        <aside id="sidebar">
          <a href="https://github.com/kimwalisch/primesieve/zipball/master" class="download_zip button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/kimwalisch/primesieve/tarball/master" class="download_targz button">
            <small>Download</small>
            .tar.gz file
          </a>

          <iframe src="http://ghbtns.com/github-btn.html?user=kimwalisch&repo=primesieve&type=watch&count=true&size=large" height="30" width="170" frameborder="0" scrolling="0" style="width:170px; height: 30px;" allowTransparency="true"></iframe>
          <p class="repo-owner" style="padding-top: 14px;"><a href="https://github.com/kimwalisch/primesieve"></a> is maintained by <a href="https://github.com/kimwalisch">kimwalisch</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

    <script src="javascripts/jquery-1.7.1.min.js" type="text/javascript"></script> 
    <script src="javascripts/modernizr-2.7.1.min.js" type="text/javascript"></script>
    <script src="javascripts/custom.js" type="text/javascript"></script>
  </body>
</html>
