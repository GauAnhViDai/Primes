<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <link href="stylesheets/navigation_menu.css" type="text/css" rel="stylesheet">

    <script src="javascripts/jquery-1.7.1.min.js" type="text/javascript"></script> 
    <script src="javascripts/modernizr-2.0.6.min.js" type="text/javascript"></script>
    <script src="javascripts/download.js" type="text/javascript"></script>

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>primesieve</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>primesieve</h1>
        <h2>Fast C/C++ prime number generator</h2>
        <a href="https://github.com/kimwalisch/primesieve" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">

<div id="container" style="width: 100%; margin-bottom: 40px;">
  <nav id="navigation">
    <ul>
      <li><a href=".">Home</a></li>
      <li><a href="screenshots.html">Screenshots</a></li>
      <li><a href="downloads">Downloads</a></li>
      <li><a href="build.html">Build From Source</a></li>
      <li><a href="api">API Documentation</a></li>
      <li><a href="links.html">Links</a></li>
    </ul>
  </nav>
</div>

<h2>
<a name="about" class="anchor" href="#about"><span class="octicon octicon-link"></span></a>Segmented sieve of Eratosthenes implementation</h2>
<p>Further down is a simple C++ implementation of the segmented sieve
of Eratosthenes with a few optimizations. It runs substantially faster
than "traditional" sieve of Eratosthenes implementations due to its
more efficient CPU cache usage i.e. it uses the CPU's L1 data cache
size (per core) as its sieve array size. This ensures that less then
2 percent of the memory accesses will be cache misses. This
implementation generates the primes below 10^9 in just 0.8 seconds
(single-threaded) on an Intel Core i7-4770 CPU (3.4 GHz) from 2013.</p>

<h2>
<a name="how" class="anchor" href="#how"><span class="octicon octicon-link"></span></a>How it works</h2>
<p>Suppose we want to sieve the primes up to 10^9. We chose the size
of the sieve array (named segment_size) to be the same size as the CPU's L1
data cache size per core e.g. 32768 bytes. We first generate the
sieving primes below sqrt(10^10) which are needed to cross-off
multiples. Then we start crossing-off the multiples of the first prime
2 until we reach a multiple of 2&nbsp;&gt;=&nbsp;segment_size, if this
happens we calculate the index of that multiple in the next segment
using (multiple&nbsp;-&nbsp;segment_size) and store it in a separate
array (next[]). We then cross-off the multiples of the next sieving
prime using the same procedure. Once we have crossed-off the multiples
of all sieving primes in the first segment we iterate over the sieve array
and print out (or count) the primes.</p>

<p>In order to sieve the next segment we reset the sieve array and we
increment the lower offset by the segment_size. Then we start
crossing-off multiples again, for each sieving prime we retrieve the
sieve index from the next array an we start crossing-off multiples
from there on...</p>

<div class="highlight highlight-C++"><pre><span class="c1">/// @file   segmented_sieve.cpp</span>
<span class="c1">/// @author Kim Walisch, &lt;kim.walisch@gmail.com&gt; </span>
<span class="c1">/// @brief  This is a simple implementation of the segmented sieve of</span>
<span class="c1">///         Eratosthenes with a few optimizations. It generates the</span>
<span class="c1">///         primes below 10^9 in 0.8 seconds (single-threaded) on an</span>
<span class="c1">///         Intel Core i7-4770 CPU (3.4 GHz) from 2013.</span>
<span class="c1">///         This is free software released into the public domain.</span>

<span class="cp">#include &lt;iostream&gt;</span>
<span class="cp">#include &lt;algorithm&gt;</span>
<span class="cp">#include &lt;cmath&gt;</span>
<span class="cp">#include &lt;vector&gt;</span>
<span class="cp">#include &lt;cstdlib&gt;</span>
<span class="cp">#include &lt;stdint.h&gt;</span>

<span class="k">const</span> <span class="kt">int</span> <span class="n">L1D_CACHE_SIZE</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>

<span class="c1">/// Generate primes using the segmented sieve of Eratosthenes.</span>
<span class="c1">/// This algorithm uses O(n log log n) operations and O(sqrt(n)) space.</span>
<span class="c1">/// @param limit         Sieve primes &lt;= limit.</span>
<span class="c1">/// @param segment_size  Size of the sieve array in bytes.</span>
<span class="c1">///</span>
<span class="kt">void</span> <span class="nf">segmented_sieve</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">limit</span><span class="p">,</span> <span class="kt">int</span> <span class="n">segment_size</span> <span class="o">=</span> <span class="n">L1D_CACHE_SIZE</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sqrt</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">sqrt</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span> <span class="n">limit</span><span class="p">);</span>
  <span class="kt">int64_t</span> <span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="c1">// vector used for sieving</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">segment</span><span class="p">(</span><span class="n">segment_size</span><span class="p">);</span>

  <span class="c1">// generate small primes &lt;= sqrt</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">is_prime</span><span class="p">(</span><span class="n">sqrt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">sqrt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">is_prime</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">sqrt</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">is_prime</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">primes</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">next</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">low</span> <span class="o">&lt;=</span> <span class="n">limit</span><span class="p">;</span> <span class="n">low</span> <span class="o">+=</span> <span class="n">segment_size</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">fill</span><span class="p">(</span><span class="n">segment</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">segment</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">1</span><span class="p">);</span>

    <span class="c1">// current segment = interval [low, high]</span>
    <span class="kt">int64_t</span> <span class="n">high</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">segment_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>

    <span class="c1">// store small primes needed to cross off multiples</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">s</span> <span class="o">*</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">;</span> <span class="n">s</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">is_prime</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
      <span class="p">{</span>
        <span class="n">primes</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">s</span><span class="p">);</span>
          <span class="n">next</span><span class="p">.</span><span class="n">push_back</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">s</span> <span class="o">*</span> <span class="n">s</span> <span class="o">-</span> <span class="n">low</span><span class="p">));</span>
      <span class="p">}</span>

    <span class="c1">// segmented sieve of Eratosthenes</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">primes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">primes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">segment_size</span><span class="p">;</span> <span class="n">j</span> <span class="o">+=</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">segment</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">next</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">segment_size</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">segment</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">low</span><span class="p">])</span>
        <span class="n">count</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">count</span> <span class="o">&lt;&lt;</span> <span class="s">" primes found."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// Usage: ./segmented_sieve n size</span>
<span class="c1">/// @param n     Sieve the primes up to n.</span>
<span class="c1">/// @param size  Size of the sieve array in bytes.</span>
<span class="c1">///</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// generate the primes below this number</span>
  <span class="kt">int64_t</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">100000000</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="n">atol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">L1D_CACHE_SIZE</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>

  <span class="n">segmented_sieve</span><span class="p">(</span><span class="n">limit</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<h2>
<a name="build-and-run" class="anchor" href="#build-and-run"><span class="octicon octicon-link"></span></a>How to build and run it</h2>

<div class="highlight highlight-bash"><pre><span class="c"># Compile using default C++ compiler</span>
<span class="nv">$ </span>c++ -O2 segmented_sieve.cpp -o segmented_sieve

<span class="c"># Count the primes below 10^9 using a segment size of 32 kilobytes</span>
<span class="nv">$ </span>./segmented_sieve <span class="k">$((</span><span class="m">10</span><span class="o">**</span><span class="m">9</span><span class="k">))</span> 32768
50847534 primes found.

real    0m2.009s
user    0m1.996s
sys     0m0.000s
</pre></div>

        </section>

        <aside id="sidebar">
          <a href="https://github.com/kimwalisch/primesieve/zipball/master" id="download_zip" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/kimwalisch/primesieve/tarball/master" id="download_targz" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/kimwalisch/primesieve"></a> is maintained by <a href="https://github.com/kimwalisch">kimwalisch</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
